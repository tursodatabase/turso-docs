---
title: AI & Embeddings
description: Vector Similarity Search is built into Turso and libSQL Server as a native feature.
---

Turso and libSQL enables vector search capability without an extension.

<Snippet file="technical-preview-banner.mdx" />

## Hot it works

- You create a table with one or more vector columns (e.g. `FLOAT32`)
- You provide vector values in binary format or convert text representation to binary with the appropriate conversion function (e.g. `vector32(...)`)
- You can calculate vectors similarity between vectors in the table or from the query itself with dedicated vector functions (e.g. `vector_distance_cos`)
- You can create special vector index in order to speed up nearest neighbors queries (use `libsql_vector_idx(column)` expression in the `CREATE INDEX` statement to create vector index)
- You can query index with special `vector_top_k(idx_name, q_vector, k)` [table-valued function](https://www.sqlite.org/vtab.html#table_valued_functions)

## Vector types

LibSQL uses native SQLite BLOB [storage class](https://www.sqlite.org/datatype3.html#storage_classes_and_datatypes) for vector columns. In order to align with SQLite [affinity rules](https://www.sqlite.org/datatype3.html#determination_of_column_affinity) all type names have 2 alternatives: one which is easy to type and another with `_BLOB` suffix which is consistent with affinity rules.

<Info>
We suggest library authors to use type names with `_BLOB` suffix in order to make result more generic and universal. For the regular application, developer can choose any alternative he like as type name only plays a role of **hint** for SQLite and external extensions.
</Info>

<Info>
As LibSQL do not introduce new storage class -- all metadata about vector also encoded in the `BLOB` itself. This comes at the price of few bytes per every row, but simplify design of the feature a lot.
</Info>

The table below lists 6 vector types supported by LibSQL at the moment. Types are listed from more precise and more storage heavy to more compact but less precise alternatives (amount of dimensions in vector $D$ used to esimate storage requirements for single vector).
 
| Type name                  | Storage (bytes)    | Description |
| -------------------------- | ------------------ | ----------- |
| `FLOAT64` / `F64_BLOB`     | $8D + 1$           | implementation of [IEEE 754 double precision format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) for 64-bit floating point numbers |
| `FLOAT32` / `F32_BLOB`     | $4D$               | implementation of [IEEE 754 single precision format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format) for 32-bit floating point numbers |
| `FLOAT16` / `F16_BLOB`     | $2D + 1$           | implementation of [IEEE 754-2008 half precision format](https://en.wikipedia.org/wiki/Half-precision_floating-point_format) for 16-bit floating point numbers |
| `FLOATB16` / `FB16_BLOB`   | $2D + 1$           | implementation of [bfloat16 format](https://en.wikipedia.org/wiki/Bfloat16_floating-point_format) for 16-bit floating point numbers |
| `FLOAT8` / `F8_BLOB`       | $D + 14$           | LibSQL specific implementation which compresses each vector component to single `u8` byte `b` and reconstruct value from it using simple transformation: $\texttt{shift} + \texttt{alpha} \cdot b$ |
| `FLOAT1BIT` / `F1BIT_BLOB` | $\lceil \frac{D}{8} \rceil + 3$ | LibSQL specific implementation which compresses each vector component down to 1-bit and pack multiple components into single machine word - thus achieving very compact representation |

<Info>
For most applications `FLOAT32` type should be a good starting point, but you may want to explore more compact options if your table has huge amount of rows with vectors.
</Info>

<Info>
While `FLOAT16` and `FLOATB16` uses same amount of storage provides different tradeoffs between speed and accuracy. Genearally, operations over `bfloat16` are faster but this come in exchange to lower precision.
</Info>

## Vector functions

In order to work with vectors LibSQL provides several functions which operates on the vector domain. Every function understand vector in binary format aligned with 6 types described above or in text format as a single JSON array of numbers.

At the moment LibSQL supports following functions:

| Function name              | Description |
| -------------------------- | ----------- |
| `vector64`, `vector32`, `vector16`, `vectorb16`, `vector8`, `vector1bit` | Conversion function shiwh accepts valid vector and convert it to the corresponding target type |
| `vector`     | Alias for `vector32` conversion function |
| `vector_extract`     | Extraction function which accepts valid vector and return its text representation |
| `vector_distance_cos`   | Cosine distance (1 - [cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity)) function which operates over vector of **same type** with **same dimensions** |
| `vector_distance_l2`   | Euclidian distance function which operates over vector of **same type** with **same dimensions** |

## Vector index

## Usage


## Usage

<Steps>

<Step title="Create a table">

Begin by declaring a column used for storing vectors with the `F32_BLOB` datatype:

```sql
CREATE TABLE movies (
  title TEXT,
  year INT,
  embedding F32_BLOB(3) -- 3-dimensional f32 vector
);
```

The number in parentheses (3) specifies the dimensionality of the vector. This means each vector in this column will have exactly 3 components.

</Step>

<Step title="Generate and insert embeddings">

Once you generate embeddings for your data (via an LLM), you can insert them into your table:

```sql
INSERT INTO movies (title, year, embedding)
VALUES
  ( 'Napoleon', 2023, vector('[1,2,3]')),
  ( 'Black Hawk Down', 2001, vector('[10,11,12]')),
  ( 'Gladiator', 2000, vector('[7,8,9]')),
  ( 'Blade Runner', 1982, vector('[4,5,6]'));
```

Popular tools like [LangChain](https://www.langchain.com), [Hugging Face](https://huggingface.co) or [OpenAI](https://turso.tech/blog/how-to-generate-and-store-openai-vector-embeddings-with-turso) can be used to generate embeddings.

</Step>

<Step title="Peform a vector similarity search">

You can now write queries combining vectors and standard SQLite data:

```sql
SELECT title,
       vector_extract(embedding),
       vector_distance_cos(embedding, vector('[5,6,7]'))
FROM movies;
```

<Note>
  The `vector_distance_cos` function calculates the cosine **distance**, which
  equals to 1 - [cosine
  similarity](https://en.wikipedia.org/wiki/Cosine_similarity). Therefore, a
  smaller distance indicates that the vectors are closer to each other.
</Note>

</Step>

<Step title="Combine regular table data with vector search">

You can combine vector search with regular query:

```sql
SELECT *
FROM
  movies
WHERE
  year >= 2020
ORDER BY
  vector_distance_cos(embedding, '[3,1,2]')
LIMIT 3;
```

This query demonstrates how to combine traditional SQL filtering (`year >= 2020`) with vector similarity search.

</Step>

</Steps>

## Indexing

Turso implements **Approximate Nearest Neighbors** (ANN) using the DiskANN algorithm for larger datasets.

<Steps>

<Step title="Create an Index">

Create an index using the `libsql_vector_idx` function:

```sql
CREATE INDEX movies_idx ON movies ( libsql_vector_idx(embedding) );
```

This creates an index optimized for vector similarity searches on the `embedding` column.

<Note>
  The `libsql_vector_idx` marker function is **required** and used by libSQL to
  distinguish `ANN`-indices from ordinary B-Tree indices.
</Note>

</Step>

<Step title="Query the indexed table">

```sql
SELECT title, year FROM vector_top_k('movies_idx', vector('[4,5,6]'), 3)
JOIN movies ON movies.rowid = id
WHERE year >= 2020;

-- alternatively, you can just filter results with IN operator
SELECT title, year FROM movies
WHERE rowid IN vector_top_k('movies_idx', vector('[4,5,6]'), 3) AND
      year >= 2020;
```

This query uses the `vector_top_k` [table-valued function](https://www.sqlite.org/vtab.html#table_valued_functions) to efficiently find the top 3 most similar vectors to `[4,5,6]` using the index.

</Step>

</Steps>

## Things to know

- Internall ANN-index use `rowid` as an identifier for rows in base table instead of natural `PRIMARY KEY`.
- Vectors are stored as an SQLite `BLOB` using the `vector` function.
